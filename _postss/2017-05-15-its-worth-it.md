---
layout: blog_post
title: 'It‚Äôs Worth It: Leaving a Full-time Software Development Job at 18 to Learn Computer Science'
date: 2017-05-15
categories:
tags: [self-written, personal-blog, life-event, medium]
rating: 5
date_published: 2017-05-15
summary: "This is why I left a full-time software development job to study computer science."
---

_This post was also published on [Medium](https://medium.com/the-mission/its-worth-it-a2cd7125ea98)_

In high school, I assumed I would go to a university. I grew up in a family that
valued education, so even after I graduated and started a gap year, I wasn‚Äôt
seriously considering any alternatives. I planned on studying computer science
in college ‚Äî as a self-taught web programmer who didn‚Äôt know much about the
underlying concepts, I thought a degree from a good school would help my career.

![](https://cdn-images-1.medium.com/max/1200/0*rsvsR_eE6pcv2NYF.)
<span class="figcaption_hack">Pictured: a visionary technologist poses with some guy who was early enough on
Twitter to get the handle @jack</span>

That plan was scrapped when I [got a full-time programming job at Braintree
](https://qz.com/575810/the-life-of-a-17-year-old-full-time-software-engineer-in-san-francisco/)during
my gap year. At first, I felt way out of my depth. Sooner or later, I‚Äôd be
exposed, and I‚Äôd be forced to head back to school; shame on me for thinking I
could take a shortcut!

But as time went on, I got better at my job. Eventually, I felt like I more or
less ‚Äúbelonged‚Äù as a productive junior developer, which once seemed impossible
given my lack of credentials. I was familiar with the tools and the team, and I
was working on increasingly challenging problems. I almost deluded myself into
thinking I was figuring everything out, so it was hard to imagine gaining
anything from a university computer science education that I couldn‚Äôt learn on
the job.

Then I met Oz and Myles.

### Why learn computer science?

They pitched me their mission: teach computer science to folks who have
practical programming knowledge but are missing fundamentals.

I thought it might work for others, but I was doing fine at my job and didn‚Äôt
see how discussing compiler theory would make me any better at it. But over the
next few weeks, I realized something: maybe I wasn‚Äôt noticing computer science
concepts around me because I wasn‚Äôt equipped to participate at that level of
discourse.

When my team decided to use Apache Kafka to pass messages between two
applications, I thought, ‚ÄúSounds great, what Ruby methods do I use?‚Äù instead of
‚ÄúIs a real-time fault-tolerant distributed streaming platform the best choice
here?‚Äù If I had a valid-looking ORM statement but the database query was still
slow, my solution was to pull up the query plan and hand it off to a senior
engineer.And if I couldn‚Äôt configure something, I rolled up my sleeves‚Ä¶and
opened Slack to message the last editor of the Wiki page I was following.

![](https://cdn-images-1.medium.com/max/1600/0*a_qkQeMxe02oXXLh.)
<span class="figcaption_hack">Teachers performing a teaching</span>

Was this really holding me back day-to-day? Maybe, maybe not. But I was afraid
of the idea that I‚Äôd eventually plateau: I might know Rails stone cold, but
where would I go from there? I wasn‚Äôt sure how to reach higher levels of
abstraction, where I could pick the right tool for a problem or quickly
conceptualize complex systems. Lower levels of abstraction, like optimizing
database queries beyond ‚Äúcross your fingers and add an index!‚Äù, were equally out
of reach. In the long run, this seemed both unacceptable and unsustainable.

### Taking the Plunge

Now I had the vague idea that ‚Äúlearning computer science‚Äù was a ‚Äúgood‚Äù and
‚Äúworthwhile‚Äù thing to do. Okay. I was still 17 at the time, so my first instinct
was to give it the ol‚Äô college try. But then I thought: does it have to take
four years, and are all those general ed classes mandatory, and is a lecture
hall with hundreds of other students the best environment for me to learn this
material?

Well, I‚Äôm pretty self-motivated, so maybe online courses are an option. Let me
just go on Coursera and‚Ä¶whoa, that‚Äôs a lot of choices. Hmm, I mostly see
‚Äúbeginner‚Äù and ‚Äúadvanced‚Äù courses, but where should someone with working web
development knowledge start? Did I need to know operating systems before I
learned networking? Could I learn about distributed systems without doing
computer architecture first?

I settled on trying an Algorithms class. I got through the first week, found
myself stuck on a problem in the second week, and stopped there because‚Ä¶well,
was this really providing value to my company‚Äôs users? That‚Äôs what I told
myself, anyways. Some superheroes might be able to [power through on their
own](https://www.scotthyoung.com/blog/myprojects/mit-challenge-2/), but I felt
like I‚Äôd have a better time in a setting with clear focus, great teachers, and
bright peers.

### Study, sleep, üîÅ

So, to make a short story long, that‚Äôs how I ended up at
[Bradfield](https://www.bradfieldcs.com/). I committed to studying computer
science full-time from this past January through March. The goal was to learn
enough to be indistinguishable from somebody with a four-year CS degree, at
least so far as my future colleagues could tell.

(I want to quickly make a distinction between programming and computer science,
in case it sounds like I was leaving my job to learn how to do my job. As
[user4501 on StackOverflow puts
it](https://softwareengineering.stackexchange.com/a/137106), ‚Äúcomputer science
is the study of what computers (can) do; programming is the practice of making
computers do things‚Äù.While they are related, it‚Äôs possible to program and get
paid for it without knowing computer science.)

I took all nine classes offered, in order:

* Computer Architecture
* Languages and Compilers
* Algorithms and Data Structures
* Operating Systems
* Databases
* Computer Networking
* Distributed Systems
* Program Interfaces
* Discrete Math

![](https://cdn-images-1.medium.com/max/1200/0*u7-ns2DpcD4XEm_2.)
<span class="figcaption_hack">Rare candid picture of the craftsman honing his trade</span>

This was divided into three classes every three weeks. Classes were every
weekday evening and weekends during the day, to accommodate students with
full-time jobs. I spent most of my days reviewing previous sessions and
preparing for future sessions. It added up to ~50 hours per week, split evenly
between class and studying. The material mirrored university courses; we used
textbooks and online videos published by schools like Berkeley and Stanford. In
fact, Oz and Myles have graciously created [a
site](https://www.teachyourselfcs.com/) with more or less the same curriculum I
went through.

Class was generally split in half, starting with a concept-driven discussion led
by the instructor. Since we had already read about these concepts, this was less
a lecture and more a time to fill in gaps and go over the confusing stuff. The
second half was spent applying those concepts. In one class, for example, we
discussed what a database‚Äôs query planner does, and then analyzed SQL statements
and their query plans with a live PostgreSQL database.

In addition to class time, I had open lines of communication with the teachers,
both in person and on Slack. I usedthis for things like asking for one-on-one
time to solidify concepts I had trouble grasping, or discussing how the
different classes tied together.

![](https://cdn-images-1.medium.com/max/1600/0*8MoZz6vyaUMmMdbh.)
<span class="figcaption_hack">Whiteboarding a finite state machine that describes a reliable transport layer
network protocol</span>

### Reflections

Here are some thoughts on my experience:

* All of my classmates were sharp, motivated, excellent people. Learning hard
things with them was a pleasure.
* Most were professional web developers, so we were able to anchor new concepts to
existing practical knowledge. Thoughts like ‚Äúwow, I wish I had known this when
designing/developing/debugging project ABC‚Äù were commonly echoed during class.
This also meant that we were able to jump quickly into deeper subject matter,
without spending time on things like development environments or syntax.
* Since a lot of the coursework is theory-heavy, I was worried about getting bored
or losing motivation like I had with the Coursera course. Oz and Myles are
engaging and responsive teachers, and they have created an environment with
self-motivated students who are all eager to learn. There were lulls, and some
topics were more interesting than others, but I never felt checked out or
unengaged. They deserve a lot of credit for that.
* This was Bradfield‚Äôs first time using structured classes, and some parts were
rough around the edges. Some in-class exercises ran into unfortunate blockers
that took up class time. Some classes dragged and could have been covered in an
hour and a half, while others felt like they needed five hours. But these
weren‚Äôt deal-breakers, and Oz and Myles are so responsive that they‚Äôve probably
ironed most of this out by now.

![](https://cdn-images-1.medium.com/max/1200/0*UeqH_03x1gZCx8kQ.)
<span class="figcaption_hack">Some notes from the operating systems class</span>

The most important takeaways for me were new mental models and increased
confidence in approaching difficult subjects.

These mental models unlock new abilities and better ways of doing common things.
For example, I can now start on even footing in an evaluation of a distributed
system‚Äôs consistency, reliability, and availability. While I frustrated myself
trying to memorize jQuery‚Äôs library of function calls to navigate the DOM
before, now I can view the DOM as a tree in my head, and recognize that moving
around it is just like traversing any other tree. These kinds of
pattern-matching and critical assessment skills are universally useful and
unlikely to go out of style.

The course list above was very intimidating at first. Discrete math?! I hadn‚Äôt
done math of any kind since high school, and definitely none of the discrete
variety. Each course title was scary in its own way and, as a whole, the
subjects seemed like they were for people smarter than me.

And the curriculum *did* turn out to be extremely challenging. But it was not
impossible! And that was ultimately comforting. My brain dragged its feet as it
stretched in new ways, but eventually pieces started to fall together, and I
could feel myself learning! Oz even made that math class bearable. Now that I‚Äôm
on the other side of these ‚Äúunreachable‚Äù things, I‚Äôm no longer afraid of
situations like staring at a 1000-page computer networking textbook without any
knowledge of computer networking. Call me a lunatic, but it was actually kind of
fun.

![](https://cdn-images-1.medium.com/max/1600/1*wxLvhlSoaRdnJc5D5V61pg.jpeg)
<span class="figcaption_hack">Annotating a copy of Amazon‚Äôs DynamoDB paper</span>

Regarding my original goal of quacking like somebody with a more formal computer
science education, the jury‚Äôs still out. My narrative is incomplete ‚Äî I
obviously don‚Äôt have experience with university computer science, and I haven‚Äôt
gone back to the workforce to apply what I‚Äôve learned in earnest. Reflecting
recently with Oz, he told me that no one really uses everything in computer
science every day. Instead, I should aim to solidify the most important
concepts, but know the fringier ones well enough to reach the ‚Äúsame level of
fuzziness‚Äù on them as classically trained folk ‚Äî not necessarily immediate
recall, but an idea of the vocabulary and where to look for an answer. That
seems realistic to me.

Even though I don‚Äôt feel like an expert yet, I‚Äôm happy with what I learned in
those three months. Say I took a year off from programming without attending
Bradfield: upon returning, I would have despaired at three new Ruby releases,
six Rails updates, and 47 new Node.js versions. It would be a nightmare to get
back up to speed! If I had a similar chunk of time away from programming now, I
could take some comfort in knowing that [computers are just carefully organized
sand](https://www.xkcd.com/1349/), CPUs still execute assembly instructions, and
that my copy of ‚ÄúThe C Programming Language‚Äù is still the latest version. Then I
suppose I‚Äôd buckle in, read some patch notes, and be on my way. Knowing these
fundamental concepts now will save me from infinite pain if I want to keep
programming for as long as people like Oz and Myles.

### Onwards

I believe that studying computer science will greatly benefit any practicing
software developer who learned how to program without a computer science
background. While a four-year university degree has been the traditional way to
get this material, Bradfield was perfect for me, and I‚Äôm confident that my
investment will pay for itself many times over.

What‚Äôs next for me? I‚Äôm starting a logistics software company that you‚Äôll hear
more about soon :). Less than a year ago, being a technical co-founder seemed
well beyond my limits. But now that I have some sturdy tools under my belt to
support any new ones, I feel well equipped for the challenge!
